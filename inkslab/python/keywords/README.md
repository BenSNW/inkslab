# 关键词抽取

## PageRank

`PageRank` 是一种通过网页之间的超链接来计算网页重要性的技术，以 `Google` 创办人 `Larry Page` 之姓来命名，`Google` 用它来体现网页的相关性和重要性。
`PageRank` 通过网络浩瀚的超链接关系来确定一个页面的等级，把从 `A` 页面到 `B` 页面的链接解释为 `A` 页面给 `B` 页面投票，`Google` 根据 `A` 页面（甚至链接到 `A` 的页面）的等级和投票目标的等级来决定 `B` 的等级。
简单的说，一个高等级的页面可以使其他低等级页面的等级提升。整个互联网可以看作是一张有向图图，网页是图中的节点，网页之间的链接就是图中的边。
如果网页 `A` 存在到网页 `B` 的链接，那么就有一条从网页 `A` 指向网页 `B` 的有向边。构造完图后，使用下面的公式来计算网页 `i` 的重要性（`PR`值）：

$$ S(V_i)=(1-d)+d\cdot\sum_{j\in In(V_i)}\frac{1}{|Out(V_j)|}S(V_j) $$

`d` 是阻尼系数，一般设置为 0.85。`In(Vi)` 是存在指向网页 `i` 的链接的网页集合。`Out(Vj)` 是网页 `j` 中的链接指向的网页的集合。
`|Out(Vj)|` 是集合中元素的个数。`PageRank` 需要使用上面的公式多次迭代才能得到结果。初始时，可以设置每个网页的重要性为 1。

## TextRank

`TextRank` 公式在 `PageRank` 公式的基础上，为图中的边引入了权值的概念：

$$ WS(V_i)=(1-d)+d\cdot\sum_{V_j\in In(Vi)}\frac{w_{ji}}{\sum_{V_k\in Out(V_j)}w_{jk}}WS(V_j) $$

`wij` 就是是为图中节点 `Vi` 到 `Vj` 的边的权值 。`d` 依然为阻尼系数，代表从图中某一节点指向其他任意节点的概率，一般取值为0.85。
`In(Vi)` 和 `Out(Vi)` 也和 `PageRank` 类似，分别为指向节点 `Vi` 的节点集合和从节点 `Vi` 出发的边指向的节点集合。

## 使用 TextRank 提取关键词

现在是要提取关键词，如果把单词视作图中的节点（即把单词看成句子），那么所有边的权值都为 0（两个单词没有相似性），所以通常简单地把所有的权值都设为 1。
此时算法退化为 `PageRank`，因而把关键字提取算法称为 `PageRank` 也不为过。

我们把文本拆分为单词，过滤掉停用词（可选），并只保留指定词性的单词（可选），就得到了单词的集合。假设一段文本依次由下面的单词组成：

$$ w_1,w_2,w_3,w_4,w_5,…,w_n $$

如果我们设定窗口大小为 `k`，那么 `[w1,w2,…,wk]`、`[w2,w3,…,wk+1]`、`[w3,w4,…,wk+2]` 等都是一个窗口。

现在将每个单词作为图中的一个节点，同一个窗口中的任意两个单词对应的节点之间存在着一条边。然后利用投票的原理，将边看成是单词之间的互相投票，经过不断迭代，每个单词的得票数都会趋于稳定。一个单词的得票数越多，就认为这个单词越重要。

## 运行

```bash
cd inkslab/python/keywords
python test.py
```
或者：

```python
from inkslab.python.keywords import textrank

if __name__ == "__main__":
    doc = [["程序员", "英文", "程序", "开发", "维护", "专业", "人员", "程序员", "分为", "程序", "设计",
           "人员", "程序", "编码", "人员", "界限", "特别", "中国", "软件", "人员", "分为", "程序员", "高级",
           "程序员", "系统", "分析员", "项目", "经理"]]

    rank = textrank.KeywordTextRank(doc)
    rank.solve()

    for w in rank.top_index(5):
        print(w)
```